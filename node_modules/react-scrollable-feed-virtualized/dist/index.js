'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".styles_scrollable-div__prSCv {\n  max-height: inherit;\n  height: inherit;\n  overflow-y: auto;\n  position: relative;\n  height: 100%;\n}\n";
var styles = {"scrollable-div":"styles_scrollable-div__prSCv","scrollableDiv":"styles_scrollable-div__prSCv"};
styleInject(css_248z);

var buffer = 3;
var ScrollableFeedVirtualized = /** @class */ (function (_super) {
    __extends(ScrollableFeedVirtualized, _super);
    function ScrollableFeedVirtualized(props) {
        var _this = _super.call(this, props) || this;
        _this.wrapperRef = React.createRef();
        _this.childWrapperRef = React.createRef();
        _this.topRef = React.createRef();
        _this.bottomRef = React.createRef();
        _this.handleScroll = _this.handleScroll.bind(_this);
        _this.handleKeyDown = _this.handleKeyDown.bind(_this);
        _this.handleMouseWheel = _this.handleMouseWheel.bind(_this);
        _this.handleMouseDown = _this.handleMouseDown.bind(_this);
        _this.forceScroll = true;
        _this.startIndexOverride = 0;
        _this.endIndexOverride = 0;
        return _this;
    }
    ScrollableFeedVirtualized.prototype.getSnapshotBeforeUpdate = function () {
        if (this.wrapperRef.current && this.bottomRef.current) {
            var viewableDetectionEpsilon = this.props.viewableDetectionEpsilon;
            return ScrollableFeedVirtualized.isViewable(this.wrapperRef.current, this.bottomRef.current, viewableDetectionEpsilon); //This argument is passed down to componentDidUpdate as 3rd parameter
        }
        return false;
    };
    ScrollableFeedVirtualized.prototype.componentDidUpdate = function (_a) {
        if (this.forceScroll) {
            this.scrollToBottom();
        }
    };
    ScrollableFeedVirtualized.prototype.componentDidMount = function () {
        this.scrollToBottom();
    };
    /**
     * Scrolls a parent element such that the child element will be in view
     * @param parent
     * @param child
     */
    ScrollableFeedVirtualized.prototype.scrollParentToChild = function (parent, child) {
        var viewableDetectionEpsilon = this.props.viewableDetectionEpsilon;
        if (!ScrollableFeedVirtualized.isViewable(parent, child, viewableDetectionEpsilon)) {
            //Source: https://stackoverflow.com/a/45411081/6316091
            var parentRect = parent.getBoundingClientRect();
            var childRect = child.getBoundingClientRect();
            //Scroll by offset relative to parent
            var scrollOffset = (childRect.top + parent.scrollTop) - parentRect.top;
            var _a = this.props, animateScroll = _a.animateScroll, onScrollComplete = _a.onScrollComplete;
            if (animateScroll) {
                animateScroll(parent, scrollOffset);
                onScrollComplete();
            }
        }
    };
    /**
     * Returns whether a child element is visible within a parent element
     *
     * @param parent
     * @param child
     * @param epsilon
     */
    ScrollableFeedVirtualized.isViewable = function (parent, child, epsilon) {
        epsilon = epsilon || 0;
        //Source: https://stackoverflow.com/a/45411081/6316091
        var parentRect = parent.getBoundingClientRect();
        var childRect = child.getBoundingClientRect();
        var childTopIsViewable = (childRect.top >= parentRect.top);
        var childOffsetToParentBottom = parentRect.top + parent.clientHeight - childRect.top;
        var childBottomIsViewable = childOffsetToParentBottom + epsilon >= 0;
        return childTopIsViewable && childBottomIsViewable;
    };
    /**
     * Handles the keyDown event, sets forceScroll to false if it's PageUp or ArrowUp
     */
    ScrollableFeedVirtualized.prototype.handleKeyDown = function (e) {
        var onSnapBroken = this.props.onSnapBroken;
        switch (e.keyCode) {
            case 33: // PageUp
            case 38: // ArrowUp
                this.forceScroll = false;
                onSnapBroken();
                break;
            case 145: // ScrollLock
                this.forceScroll = !this.forceScroll;
                onSnapBroken();
                break;
        }
    };
    /**
     * Handles the mouse wheel event, sets forceScroll to false
     */
    ScrollableFeedVirtualized.prototype.handleMouseWheel = function () {
        var onSnapBroken = this.props.onSnapBroken;
        this.forceScroll = false;
        onSnapBroken();
    };
    /**
     * Handles the mouse down event, sets forceScroll to false
     */
    ScrollableFeedVirtualized.prototype.handleMouseDown = function (e) {
        var _a = this.props, scrollBarHorizontalGap = _a.scrollBarHorizontalGap, onSnapBroken = _a.onSnapBroken;
        var gap = scrollBarHorizontalGap ? scrollBarHorizontalGap : 16;
        if (this.wrapperRef.current === e.target && (e.clientX - gap) >= e.target.clientWidth) {
            this.forceScroll = false;
            onSnapBroken();
        }
    };
    /**
     * Handles the onScroll event, forces render
     */
    ScrollableFeedVirtualized.prototype.handleScroll = function () {
        this.forceUpdate();
    };
    /**
     * Scroll to the bottom
     */
    ScrollableFeedVirtualized.prototype.scrollToBottom = function () {
        if (this.wrapperRef.current) {
            var parent_1 = this.wrapperRef.current;
            var _a = this.props, animateScroll = _a.animateScroll, onScrollComplete = _a.onScrollComplete, children = _a.children, itemHeight = _a.itemHeight;
            var childrenRef = children ? children[1] : null;
            if (animateScroll && parent_1) {
                animateScroll(parent_1, (childrenRef.length + buffer) * itemHeight);
                onScrollComplete();
            }
        }
    };
    /**
     * Scroll to a certain start index
     */
    ScrollableFeedVirtualized.prototype.scrollToIndex = function (startIndex) {
        var _a = this.props, itemHeight = _a.itemHeight, marginTop = _a.marginTop, animateScroll = _a.animateScroll, onScrollComplete = _a.onScrollComplete;
        if (this.wrapperRef.current) {
            var parent_2 = this.wrapperRef.current;
            var upperParent = this.wrapperRef.current.parentElement;
            if (upperParent) {
                var upperParentRect = upperParent.getBoundingClientRect();
                var windowHeight = upperParentRect.height;
                var actualHeight = itemHeight + marginTop;
                if (animateScroll && parent_2) {
                    animateScroll(parent_2, (startIndex + Math.floor(windowHeight / actualHeight) + 2 * buffer) * itemHeight);
                    onScrollComplete();
                }
            }
        }
    };
    /**
     * Jump to the bottom
     */
    ScrollableFeedVirtualized.prototype.jumpToBottom = function () {
        var _a = this.props, children = _a.children, itemHeight = _a.itemHeight, marginTop = _a.marginTop;
        var childrenRef = children ? children[1] : null;
        if (this.wrapperRef.current) {
            var upperParent = this.wrapperRef.current.parentElement;
            if (upperParent) {
                var upperParentRect = upperParent.getBoundingClientRect();
                var windowHeight = upperParentRect.height;
                var actualHeight = itemHeight + marginTop;
                this.startIndexOverride = childrenRef.length - Math.floor(windowHeight / actualHeight) - buffer;
                this.endIndexOverride = childrenRef.length - 1;
                this.forceUpdate();
                this.forceScroll = true;
                this.scrollToBottom();
            }
        }
    };
    ScrollableFeedVirtualized.prototype.render = function () {
        var _a = this.props, children = _a.children, className = _a.className, itemHeight = _a.itemHeight, marginTop = _a.marginTop;
        var childrenRef = children ? children[1] : null;
        if (!childrenRef) {
            return React.createElement(React.Fragment, null);
        }
        var windowHeight = 0;
        var windowTop = 0;
        if (this.wrapperRef.current) {
            var upperParent = this.wrapperRef.current.parentElement;
            if (upperParent) {
                var upperParentRect = upperParent.getBoundingClientRect();
                windowHeight = upperParentRect.height;
                windowTop = upperParentRect.top;
                var _b = this.props, animateScroll = _b.animateScroll, onScrollComplete = _b.onScrollComplete;
                if (animateScroll && upperParent) {
                    animateScroll(upperParent, (childrenRef.length + buffer) * itemHeight);
                    onScrollComplete();
                }
            }
        }
        var numItems = children ? children[1].length : 0;
        var top = 0;
        if (this.topRef.current) {
            var topRect = this.topRef.current.getBoundingClientRect();
            if (topRect.top < windowTop) {
                top = windowTop - topRect.top;
            }
        }
        var actualHeight = itemHeight + marginTop;
        var startIndex = Math.floor(top / actualHeight);
        var endIndex = Math.min(numItems - 1, // don't render past the end of the list
        Math.floor((top + windowHeight) / actualHeight));
        startIndex -= buffer;
        endIndex += buffer;
        if (startIndex < 0) {
            startIndex = 0;
        }
        if (this.startIndexOverride > 0) {
            startIndex = this.startIndexOverride;
            this.startIndexOverride = 0;
        }
        if (this.endIndexOverride > 0) {
            endIndex = this.endIndexOverride;
            this.endIndexOverride = 0;
        }
        if (endIndex > (childrenRef.length - 1)) {
            endIndex = (childrenRef.length - 1);
        }
        var items = [];
        for (var i = startIndex; i <= endIndex; i++) {
            var item = childrenRef[i];
            item.props.style['top'] = i * actualHeight + "px";
            item.props.style['marginTop'] = marginTop + "px";
            items.push(item);
        }
        var childWrapperHeight = actualHeight * numItems;
        var joinedClassName = styles.scrollableDiv + (className ? " " + className : "");
        return (React.createElement("div", { className: joinedClassName, ref: this.wrapperRef, onScroll: this.handleScroll, onKeyDown: this.handleKeyDown, onWheel: this.handleMouseWheel, onMouseDown: this.handleMouseDown, tabIndex: 0 },
            React.createElement("div", { ref: this.childWrapperRef, style: { height: childWrapperHeight + "px" } },
                React.createElement("div", { ref: this.topRef }),
                items,
                React.createElement("div", { ref: this.bottomRef }))));
    };
    ScrollableFeedVirtualized.defaultProps = {
        itemHeight: 0,
        marginTop: 0,
        animateScroll: function (element, offset) {
            if (element.scrollBy) {
                element.scrollBy({ top: offset });
            }
            else {
                element.scrollTop = offset;
            }
        },
        onScrollComplete: function () { },
        viewableDetectionEpsilon: 2,
        onSnapBroken: function () { },
    };
    return ScrollableFeedVirtualized;
}(React.Component));

exports.default = ScrollableFeedVirtualized;
//# sourceMappingURL=index.js.map
